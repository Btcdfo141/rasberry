"""
Support for Broadlink RM devices.

For more details about this platform, please refer to the documentation at
https://home-assistant.io/components/cover.broadlink/
"""

import asyncio
import binascii
import logging
import socket
from base64 import b64decode

import voluptuous as vol

from homeassistant.components.cover import (PLATFORM_SCHEMA, CoverDevice)
from homeassistant.helpers.event import track_utc_time_change

from homeassistant.const import (CONF_NAME, CONF_HOST, CONF_MAC, CONF_TIMEOUT)

from homeassistant.helpers.event import async_track_state_change
from homeassistant.helpers.entity import async_generate_entity_id
import homeassistant.helpers.config_validation as cv
from homeassistant.core import callback

REQUIREMENTS = ['broadlink==0.5']

_LOGGER = logging.getLogger(__name__)

HOMEBRIDGE_COVER_TYPE = 'rollershutter'

DEFAULT_NAME = 'cover'

CONF_COMMAND_OPEN = 'command_open'
CONF_COMMAND_CLOSE = 'command_close'
CONF_COMMAND_STOP = 'command_stop'
CONF_POS_SENSOR = 'position_sensor'
CONF_TRAVEL_TIME = 'travel_time'
CONF_COVERS = 'covers'

COVERS_SCHEMA = vol.Schema({
    vol.Optional(CONF_COMMAND_STOP, default=None): cv.string,
    vol.Optional(CONF_COMMAND_OPEN, default=None): cv.string,
    vol.Optional(CONF_COMMAND_CLOSE, default=None): cv.string,
    vol.Optional(CONF_NAME): cv.string,
    vol.Optional(CONF_TRAVEL_TIME): vol.Coerce(float),
    vol.Optional(CONF_POS_SENSOR): cv.entity_id,
})


PLATFORM_SCHEMA = PLATFORM_SCHEMA.extend({
    vol.Optional(CONF_COVERS, default={}):
        vol.Schema({cv.slug: COVERS_SCHEMA}),
    vol.Required(CONF_HOST): cv.string,
    vol.Required(CONF_MAC): cv.string
})


@asyncio.coroutine
def async_setup_platform(hass, config, async_add_devices, discovery_info=None):

    import broadlink
    devices = config.get(CONF_COVERS)
    ip_addr = config.get(CONF_HOST)
    mac_addr = binascii.unhexlify(
        config.get(CONF_MAC).encode().replace(b':', b''))

    broadlink_device = broadlink.rm((ip_addr, 80), mac_addr)

    covers = []
    for object_id, device_config in devices.items():
        covers.append(
            RMCover(
                hass,
                object_id,
                broadlink_device,
                device_config.get(CONF_NAME,object_id),
                device_config.get(CONF_COMMAND_OPEN),
                device_config.get(CONF_COMMAND_CLOSE),
                device_config.get(CONF_COMMAND_STOP),
                device_config.get(CONF_TRAVEL_TIME),
                device_config.get(CONF_POS_SENSOR,),
            )
        )

    broadlink_device.timeout = 10
    try:
        broadlink_device.auth()
    except socket.timeout:
        _LOGGER.error("Failed to connect to device")    

    async_add_devices(covers)


class RMCover(CoverDevice):
    """Representation of a cover."""

    # pylint: disable=no-self-use
    def __init__(self, hass, entity_id, device, name, 
                    cmd_open, cmd_close, cmd_stop,
                    travel_time, pos_entity_id=None, device_class=None,):
        """Initialize the cover."""
        self.hass = hass
        self.entity_id = async_generate_entity_id(
            'cover.{}', entity_id, hass=hass)
        self._name = name
        self._cmd_open = b64decode(cmd_open) if cmd_open else None
        self._cmd_close = b64decode(cmd_close) if cmd_close else None
        self._cmd_stop = b64decode(cmd_stop) if cmd_stop else None

        self._position = 100
        self._step = round(100.0 / travel_time)
        self._device_class = device_class
        self._set_position = None
        self._requested_closing = True
        self._unsub_listener_cover = None
        self._is_opening = False
        self._is_closing = False
        self._device = device
        self._delay = False

        self._closed = self.current_cover_position <= 0

        if pos_entity_id:
            async_track_state_change(
                hass, pos_entity_id, self._async_pos_changed)
            
            temp_state = hass.states.get(pos_entity_id)
            if temp_state:
                self._async_update_pos(temp_state)
    
    @callback
    def _async_update_pos(self, state):
        if state.state is 'closed':
            self._position = 0

    @asyncio.coroutine
    def _async_pos_changed(self, entity_id, old_state, new_state):
        if new_state is None:
            return

        self._async_update_pos(new_state)
        yield from self.async_update_ha_state()


    @property
    def device_state_attributes(self):
        return {'homebridge_cover_type': HOMEBRIDGE_COVER_TYPE}

    @property
    def name(self):
        """Return the name of the cover."""
        return self._name

    @property
    def should_poll(self):
        """No polling needed for a demo cover."""
        return False

    @property
    def current_cover_position(self):
        """Return the current position of the cover."""
        return self._position

    @property
    def is_closed(self):
        """Return if the cover is closed."""
        return self._closed

    @property
    def is_closing(self):
        """Return if the cover is closing."""
        return self._is_closing

    @property
    def is_opening(self):
        """Return if the cover is opening."""
        return self._is_opening

    @property
    def device_class(self):
        """Return the class of this device, from component DEVICE_CLASSES."""
        return self._device_class

    def close_cover(self, **kwargs):
        """Close the cover."""
        if self._position == 0:
            return

        if self._position == 100:
            self._position = round(100.0 /self._step, 0) * self._step

        elif self._position is None:
            self._closed = True
            self.schedule_update_ha_state()
            return

        self._sendpacket(self._cmd_close)
        self._is_closing = True
        self._listen_cover()
        self._requested_closing = True
        self.schedule_update_ha_state()

    def open_cover(self, **kwargs):
        """Open the cover."""
        if self._position == 100:
            return
        elif self._position is None:
            self._closed = False
            self.schedule_update_ha_state()
            return

        self._sendpacket(self._cmd_open)
        self._is_opening = True
        self._listen_cover()
        self._requested_closing = False
        self.schedule_update_ha_state()

    def set_cover_position(self, position, **kwargs):
        """Move the cover to a specific position."""
        if position == 0:
            self._set_position = 0
            self._position = 99
        elif position == 100:
            self._set_position = 100
            self._position = 1
        else:            
            self._set_position = round(float(position)/self._step, 0) * self._step
        
        if self._position == position:
            return

        if position < self._position:
            self.close_cover()
        else:
            self.open_cover()

        self._listen_cover()
        self._requested_closing = position < self._position


    def stop_cover(self, **kwargs):
        """Stop the cover."""
        self._is_closing = False
        self._is_opening = False
        if self._position is None:
            return
        if self._unsub_listener_cover is not None:
            self._unsub_listener_cover()
            self._unsub_listener_cover = None
            self._set_position = None

        self._sendpacket(self._cmd_stop)

    def _listen_cover(self):
        """Listen for changes in cover."""
        if self._unsub_listener_cover is None:
            self._delay = True
            self._unsub_listener_cover = track_utc_time_change(
                self.hass, self._time_changed_cover)

    def _time_changed_cover(self, now):
        """Track time changes."""
        if self._delay:
            self._delay = False
        else:
            if self._requested_closing:
                self._position -= self._step
                if self._position < 0:
                    self._position = 0
            else:
                self._position += self._step
                if self._position > 100:
                    self._position = 100

            if self._position in (100, 0, self._set_position):
                self.stop_cover()

        self._closed = self.current_cover_position <= 0

        self.schedule_update_ha_state()


    def _sendpacket(self, packet, retry=2):
        """Send packet to device."""
        if packet is None:
            _LOGGER.debug("Empty packet")
            return True
        try:
            self._device.send_data(packet)
        except (socket.timeout, ValueError) as error:
            if retry < 1:
                _LOGGER.error(error)
                return False
            if not self._auth():
                return False
            return self._sendpacket(packet, retry-1)
        return True

    def _auth(self, retry=2):
        try:
            auth = self._device.auth()
        except socket.timeout:
            auth = False
        if not auth and retry > 0:
            return self._auth(retry-1)
        return auth
