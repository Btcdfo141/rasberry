"""
Support for the Fibaro devices.

To enable, add the following section to configuration.yaml:
[fibaro]
    url: "http://yourfibarohc/api/"
    username: "your@superuseremail.com"
    password: "YourPassword1"

For more detailed debugging, you can enable it in the [logger] section of you
configuration.yaml, like this:
[logger]
    logs:
        homeassistant.components.fibaro: debug
"""

import logging
from collections import defaultdict
import threading
import voluptuous as vol
from homeassistant.const import (ATTR_ARMED, ATTR_BATTERY_LEVEL,
                                 CONF_PASSWORD, CONF_URL, CONF_USERNAME)
import homeassistant.helpers.config_validation as cv
from homeassistant.util import convert, slugify
from homeassistant.helpers import discovery
from homeassistant.helpers.entity import Entity

REQUIREMENTS = ['fiblary3==0.1.7']

_LOGGER = logging.getLogger(__name__)
DOMAIN = 'fibaro'
FIBARO_DEVICES = 'fibaro_devices'
FIBARO_SCENES = 'fibaro_scenes'
FIBARO_CONTROLLER = 'fibaro_controller'
FIBARO_ID_FORMAT = '{}_{}'
ATTR_CURRENT_POWER_W = "current_power_w"
ATTR_CURRENT_ENERGY_KWH = "current_energy_kwh"

FIBARO_COMPONENTS = [
    'binary_sensor',
    'sensor',
    'light',
    'switch',
    # 'lock',
    # 'climate',
    'cover',
    # 'scene'
]

FIBARO_TYPE_MAPPING = {
    'com.fibaro.temperatureSensor': 'sensor',
    'com.fibaro.multilevelSensor': "sensor",
    'com.fibaro.humiditySensor': 'sensor',
    'com.fibaro.binarySwitch': 'switch',
    'com.fibaro.FGRGBW441M': 'light',
    'com.fibaro.multilevelSwitch': 'switch',
    'com.fibaro.FGD212': 'light',
    'com.fibaro.FGRM222': 'cover',
    'com.fibaro.FGR': 'cover',
    'com.fibaro.doorSensor': 'binary_sensor',
    'com.fibaro.FGMS001v2': 'binary_sensor',
    'com.fibaro.lightSensor': 'sensor',
    'com.fibaro.seismometer': 'sensor',
    'com.fibaro.accelerometer': 'sensor',
    'com.fibaro.FGSS001': 'sensor',
    'com.fibaro.remoteSwitch': 'switch',
    'com.fibaro.sensor': 'sensor',
    'com.fibaro.colorController': 'sensor'
}

CONFIG_SCHEMA = vol.Schema({
    DOMAIN: vol.Schema({
        vol.Required(CONF_PASSWORD): cv.string,
        vol.Required(CONF_USERNAME): cv.string,
        vol.Required(CONF_URL): cv.string
    })
}, extra=vol.ALLOW_EXTRA)


class FibaroController():
    """Initiate Fibaro Controller Class."""

    my_rooms = None
    my_devices = None
    my_fibaro_devices = None
    devices_lock = None
    callbacks = {}
    client = None

    def __init__(self, hass, username, password, url):
        """Initialize the communication with the Fibaro controller."""
        from fiblary3.client.v4.client import Client as FibaroClient
        self.devices_lock = threading.Lock()
        self.client = FibaroClient(url, username, password)
        # try:
        #     my_info = self.info.get()
        # except:
        #     _LOGGER.error("Failed to connect to Fibaro HC")
        #     raise ValueError('Failed to connect to Fibaro HC.')

        my_login = self.client.login.get()
        if my_login is None or my_login.status is False:
            _LOGGER.error("Invalid login for Fibaro HC. "
                          "Please check username and password.")
            raise ValueError("Invalid login for Fibaro HC. "
                             "Please check username and password.")

        self._read_rooms()
        self._read_devices()

        self.client.add_event_handler('value', self.generic_handler)
        self.client.add_event_handler('value2', self.generic_handler)
        self.client.add_event_handler('batteryLevel', self.generic_handler)
        self.client.add_event_handler('power', self.generic_handler)
        self.client.add_event_handler('energy', self.generic_handler)
        self.client.add_event_handler('brightness', self.generic_handler)
        self.client.add_event_handler('log', self.log_handler)
        self.client.add_event_handler('color', self.generic_handler)
        self.client.add_event_handler('lastColorSet', self.generic_handler)
        self.client.add_event_handler('lastUpdated', self.generic_handler)
        self.client.add_event_handler('lastOutdoorUpdated',
                                      self.generic_handler)

        # these are generated by YR weather component
        self.client.add_event_handler('Humidity', self.generic_handler)
        self.client.add_event_handler('Pressure', self.generic_handler)
        self.client.add_event_handler('Temperature', self.generic_handler)
        self.client.add_event_handler('Wind', self.generic_handler)
        self.client.add_event_handler('sunriseHour', self.generic_handler)
        self.client.add_event_handler('sunsetHour', self.generic_handler)
        self.client.add_event_handler('ui.Current_Weather_Label.caption',
                                      self.generic_handler)

        # these could be useful, but not implemented yet
        self.client.add_event_handler('logTemp', self.dummy_handler)
        hass.data[FIBARO_CONTROLLER] = self
        hass.data[FIBARO_DEVICES] = self.my_fibaro_devices

    def generic_handler(self, **kwargs):
        """Process the value change event of a device."""
        try:
            change_property = kwargs.get('property', None)
            change_id = kwargs.get('id', None)
            dev_name = self.my_devices[change_id].friendly_name
            change_value = kwargs.get('value', None)
            if change_property in self.my_devices[change_id].properties:
                with self.devices_lock:
                    self.my_devices[change_id].properties[change_property] =\
                        change_value
            else:
                _LOGGER.error("Error updating %s data of %s, not found",
                              change_property, dev_name)
            if self.callbacks.get(change_id, None):
                self.callbacks[change_id]()
            else:
                _LOGGER.debug("No callback to update %s data for %s",
                              change_property, dev_name)
        except KeyError:
            _LOGGER.error("KeyError updating %s data for %s",
                          change_property, dev_name)
        except ValueError:
            _LOGGER.error("ValueError updating %s data for %s",
                          change_property, dev_name)
        _LOGGER.info('Received update %s: %s to %s', change_property,
                     dev_name, str(change_value))

    def log_handler(self, **kwargs):
        """Process the logging event of a device."""
        change_id = kwargs.get('id', None)
        change_value = kwargs.get('value', None)
        if change_value:
            if change_value != "transfer OK":
                _LOGGER.info("Fibaro %s: %s: %s",
                             kwargs.get('property', 'unknown'),
                             self.my_devices[change_id].friendly_name,
                             str(change_value))

    def dummy_handler(self, **kwargs):
        """Process the nothingness of the universe."""
        pass

    def get_device_name(self, device):
        """Get room decorated name for Fibaro device."""
        if device.roomID == 0:
            room_name = 'Unknown'
        else:
            room_name = self.my_rooms[device.roomID].name
        device_name = room_name + '_' + device.name
        return device_name

    def register(self, device_id, callback):
        """Register device with a callback for updates."""
        self.callbacks[device_id] = callback

    def _read_rooms(self):
        """Read and process the room list."""
        rooms = self.client.rooms.list()
        self.my_rooms = {}
        for room in rooms:
            self.my_rooms[room.id] = room
        return True

    def _read_devices(self):
        """Read and process the device list."""
        devices = self.client.devices.list()
        with self.devices_lock:
            self.my_devices = {}
            for device in devices:
                device.friendly_name = self.get_device_name(device)
                self.my_devices[device.id] = device
            if self.my_fibaro_devices is None:
                self.my_fibaro_devices = defaultdict(list)
            for _, device in self.my_devices.items():
                if (device.enabled is True) and (device.visible is True):
                    if device.type in FIBARO_TYPE_MAPPING:
                        device_type = FIBARO_TYPE_MAPPING[device.type]
                    elif device.baseType in FIBARO_TYPE_MAPPING:
                        device_type = FIBARO_TYPE_MAPPING[device.type]
                    else:
                        continue
                    if device_type == 'switch' and \
                            'isLight' in device.properties and \
                            device.properties.isLight == 'true':
                        device_type = 'light'
                    device.mapped_type = device_type
                    self.my_fibaro_devices[device_type].append(device)
        return True


def setup(hass, config):
    """Set up the Fibaro Component."""
    username = config[DOMAIN][CONF_USERNAME]
    password = config[DOMAIN][CONF_PASSWORD]
    url = config[DOMAIN][CONF_URL]
    controller = FibaroController(hass, username, password, url)

    for component in FIBARO_COMPONENTS:
        discovery.load_platform(hass, component, DOMAIN, {}, config)

    controller.client.enable_state_handler()

    return True


class FibaroDevice(Entity):
    """Representation of a Fibaro device entity."""

    def __init__(self, fibaro_device, controller):
        """Initialize the device."""
        self.fibaro_device = fibaro_device
        self.controller = controller

        self._name = fibaro_device.friendly_name
        # Append device id to prevent name clashes in HA.
        self.ha_id = FIBARO_ID_FORMAT.format(
            slugify(self._name), fibaro_device.id)
        self.fibaro_device.ha_id = self.ha_id
        self.controller.register(fibaro_device.id, self._update_callback)

    def _update_callback(self):
        """Update the state."""
        self.schedule_update_ha_state(True)

    def get_level(self):
        """Get the level of Fibaro device."""
        if 'value' in self.fibaro_device.properties:
            return self.fibaro_device.properties.value
        return None

    def get_level2(self):
        """Get the tilt level of Fibaro device."""
        if 'value2' in self.fibaro_device.properties:
            return self.fibaro_device.properties.value2
        return None

    def dont_know_message(self, action):
        """Make a warning in case we don't know how to perform an action."""
        _LOGGER.warning("Not sure how to setValue: %s "
                        "(available actions: %s)", str(self.ha_id),
                        str(self.fibaro_device.actions))

    def set_level(self, level):
        """Set the level of Fibaro device."""
        if 'setValue' in self.fibaro_device.actions:
            self.fibaro_device.setValue(level)
            _LOGGER.info('Sent updated value: %s to %s',
                         self.ha_id, str(level))
            self.fibaro_device.properties.level = level
        else:
            self.dont_know_message("set_level")

    def set_level2(self, level):
        """Set the tilt level of Fibaro device."""
        if 'setValue2' in self.fibaro_device.actions:
            self.fibaro_device.setValue2(level)
            _LOGGER.info('Sent updated value2: %s to %s',
                         self.ha_id, str(level))
            self.fibaro_device.properties.level2 = level
        else:
            self.dont_know_message("set_level2")

    def set_color(self, color, white):
        """Set the tilt level of Fibaro device."""
        # There is apparently a bug in Fibaro's setColor API, saying
        # it needs one parameter but expecting separate parameters.
        if 'setColor' in self.fibaro_device.actions:
            if white is None:
                white = 0
            color_str = "{},{},{},{}".format(color[0], color[1],
                                             color[2], white)
            self.fibaro_device.setColor(str(color[0]), str(color[1]),
                                        str(color[2]), white)

            self.fibaro_device.properties.color = color_str

            _LOGGER.info('Sent updated color: %s to %s',
                         self.ha_id, str(color_str))
        else:
            self.dont_know_message("set_Color")

    def open(self):
        """Execute open command on Fibaro device."""
        if 'open' in self.fibaro_device.actions:
            self.fibaro_device.open()
            _LOGGER.info('Sent open command to %s',
                         self.ha_id)
        else:
            self.dont_know_message("open")

    def close(self):
        """Execute close command on Fibaro device."""
        if 'close' in self.fibaro_device.actions:
            self.fibaro_device.close()
            _LOGGER.info('Sent close command to %s',
                         self.ha_id)
        else:
            self.dont_know_message("close")

    def stop(self):
        """Execute stop command on Fibaro device."""
        if 'stop' in self.fibaro_device.actions:
            self.fibaro_device.stop()
            _LOGGER.info('Sent stop command to %s',
                         self.ha_id)
        else:
            self.dont_know_message("stop")

    def switch_on(self):
        """Switch on Fibaro device."""
        if 'turnOn' in self.fibaro_device.actions:
            self.fibaro_device.turnOn()
            _LOGGER.info('Sent turnOn command to %s',
                         self.ha_id)
        else:
            self.dont_know_message("switch_on")

    def switch_off(self):
        """Switch off Fibaro device."""
        if 'turnOff' in self.fibaro_device.actions:
            self.fibaro_device.turnOff()
            _LOGGER.info('Sent turnOff command to %s',
                         self.ha_id)
        else:
            self.dont_know_message("switch_off")

    @property
    def current_power_w(self):
        """Return the current power usage in W."""
        if 'power' in self.fibaro_device.properties:
            power = self.fibaro_device.properties.power
            if power:
                return convert(power, float, 0.0)
        else:
            return 0

    @property
    def current_binary_state(self):
        """Return the current binary state."""
        if self.fibaro_device.properties.value == 'false':
            return False
        if self.fibaro_device.properties.value == 'true':
            return True
        if int(self.fibaro_device.properties.value) > 0:
            return True
        return False

    @property
    def name(self):
        """Return the name of the device."""
        return self._name

    @property
    def should_poll(self):
        """Get polling requirement from fibaro device."""
#        return self.fibaro_device.should_poll
        return False

    @property
    def device_state_attributes(self):
        """Return the state attributes of the device."""
        attr = {}

        try:
            if 'battery' in self.fibaro_device.interfaces:
                attr[ATTR_BATTERY_LEVEL] = \
                    self.fibaro_device.properties.batteryLevel
        except ValueError:
            pass
        try:
            if 'fibaroAlarmArm' in self.fibaro_device.interfaces:
                armed = self.fibaro_device.properties.armed
                attr[ATTR_ARMED] = 'True' if armed else 'False'
        except ValueError:
            pass
        #
        # if self.fibaro_device.is_trippable:
        #     last_tripped = self.fibaro_device.last_trip
        #     if last_tripped is not None:
        #         utc_time = utc_from_timestamp(int(last_tripped))
        #         attr[ATTR_LAST_TRIP_TIME] = utc_time.isoformat()
        #     else:
        #         attr[ATTR_LAST_TRIP_TIME] = None
        #     tripped = self.fibaro_device.is_tripped
        #     attr[ATTR_TRIPPED] = 'True' if tripped else 'False'
        #
        try:
            if 'power' in self.fibaro_device.interfaces:
                power = float(self.fibaro_device.properties.power)
                if power:
                    attr[ATTR_CURRENT_POWER_W] = convert(power, float, 0.0)
        except ValueError:
            pass
        try:
            if 'energy' in self.fibaro_device.interfaces:
                energy = float(self.fibaro_device.properties.energy)
                if energy:
                    attr[ATTR_CURRENT_ENERGY_KWH] = \
                        convert(energy, float, 0.0)
        except ValueError:
            pass

        attr['Fibaro Device Id'] = self.fibaro_device.id
        attr['Id'] = self.ha_id

        return attr
